#include "cxxcodegenerator.h"

#include <QCXXHighlighter>

#include "model.h"

#include <QTextStream>

CxxCodeGenerator::CxxCodeGenerator(QWidget* parent)
  : CodeGenerator{ parent }
{
  addFormWidget(tr("Namespace"), &m_namespaceEdit);
  addFormWidget(tr("Model Class Name"), &m_modelEdit);

  m_namespaceEdit.setPlaceholderText("(anonymous)");

  m_modelEdit.setPlaceholderText("(basic_model)");

  getCodeView()->setHighlighter(&m_highlighter);

  connect(&m_namespaceEdit, &QLineEdit::textChanged, [this](const QString&) { emit propertiesChanged(); });

  connect(&m_modelEdit, &QLineEdit::textChanged, [this](const QString&) { emit propertiesChanged(); });
}

void
CxxCodeGenerator::generate(const Model& model)
{
  QString code;

  QTextStream stream(&code);

  const int connectionCount = model.getConnectionCount();

  stream << "/* Note: This file is automatically generated. Edits made could potentially be lost.\n";

  stream << '\n';

  stream << "#pragma once\n";

  stream << '\n';

  if (m_namespaceEdit.text().isEmpty())
    stream << "namespace {\n";
  else
    stream << "namespace " << m_namespaceEdit.text() << " {\n";

  stream << R"(
/** @brief Describes a neural network model.
 *
 * @tparam Scalar The type used to represent scalar values.
 *                On platforms with floating point units, this is ideally a single precision float.
 *                On embedded platforms without FPUs, this may be an integer type or custom soft float type.
 */
)";
  stream << "template <typename Scalar>\n";
  stream << "class " << getModelClassName() << " final\n";
  stream << "{\n";
  stream << "public:\n";
  stream << "  using size_type = unsigned long int;\n";
  stream << '\n';
  stream << "  static constexpr auto connection_count() noexcept -> size_type { return " << model.getConnectionCount()
         << "; }\n";

  stream << R"(
/** @brief Constructs an instance of the model.
 *
 * @detail The model allows client code to take care of memory allocation.
 *
 * @param c_buf The buffer containing the weights and biases of each connection.
 *              See @ref connection_count for the required size of this buffer.
 */
)";

  stream << "  constexpr " << getModelClassName() << "(connection* c_buf) noexcept\n";
  stream << "    : m_connections(c_buf)\n";
  stream << "  {}\n";
  stream << "\n";
  stream << "  template <typename InputIterator,\n";
  stream << "            typename OutputIterator,\n";
  stream << "            typename Activation>\n";
  stream << "  constexpr void operator()(InputIterator begin,\n";
  stream << "                            InputIterator end,\n";
  stream << "                            OutputIterator result,\n";
  stream << "                            Activation activation);\n";
  stream << '\n';
  stream << "private:\n";
  stream << "  struct connection final\n";
  stream << "  {\n";
  stream << "    Scalar weight;\n";
  stream << "\n";
  stream << "    Scalar bias;\n";
  stream << "  };\n";
  stream << "\n";
  stream << "  connection* m_connections;\n";
  stream << "};\n";

  stream << '\n';
  stream << "/* Implementation details beyond this point. */\n";
  stream << '\n';

  const QString paramIndent(getModelClassName().size() + 36, ' ');

  stream << "template <typename Scalar>\n";
  stream << "template <typename InputIterator,\n";
  stream << "          typename OutputIterator,\n";
  stream << "          typename Activation>\n";
  stream << "constexpr auto " << getModelClassName() << "<Scalar>::operator()(InputIterator begin,\n";
  stream << paramIndent << "InputIterator end,\n";
  stream << paramIndent << "OutputIterator result,\n";
  stream << paramIndent << "Activation activation)\n";
  stream << "{\n";

  const auto& outputNodes = model.getOutputNodes();

  stream << "  for (size_type i = 0; i < " << outputNodes.size() << "; i++) {\n";
  stream << "    *result = Scalar(0);\n";
  stream << "    result++;\n";
  stream << "  }\n";

  stream << "}\n";

  stream << '\n';

  if (m_namespaceEdit.text().isEmpty())
    stream << "} // namespace\n";
  else
    stream << "} // namespace " << m_namespaceEdit.text() << '\n';

  stream << '\n';

  setCode(code);
}

auto
CxxCodeGenerator::beginFuncDef(const QString& funcName, const QStringList& params, const QString& result) -> QString
{
  QString output;

  QTextStream stream(&output);

  stream << "template <typename Scalar>\n";

  stream << "auto " << getModelClassName() << "<Scalar>"
         << "::" << funcName << '(';

  for (int i = 0; i < params.size(); i++) {

    stream << params[i];

    if ((i + 1) < params.size())
      stream << ", ";
  }

  stream << ")\n";

  stream << "{\n";

  return output;
}

auto
CxxCodeGenerator::getModelClassName() const -> QString
{
  return m_modelEdit.text().isEmpty() ? "basic_model" : m_modelEdit.text();
}

